<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>DBD Scoreboard Overlay</title>
<style>
  :root{
    --scale: 1;
    --w: 980px;
    --h: 170px;
    --radius: 999px;

    --padX: 18px;
    --colW: 175px;
    --gap: 12px;

    --circle: 140px;
    --icon: 56px;
    --stackGap: 4px;

    --bg: rgba(13,13,14,.78);
    --border: rgba(255,255,255,.07);
    --textMain: #efefef;
    --textSub: #c0c0c0;
    --highlight: #ff4500;

    /* derived (JS sets) */
    --hl_10: rgba(255,69,0,.10);
    --hl_22: rgba(255,69,0,.22);
    --hl_35: rgba(255,69,0,.35);
    --hl_45: rgba(255,69,0,.45);
    --hl_55: rgba(255,69,0,.55);

    --numSize: 86px;
    --numWeight: 1000;
    --labelSize: 20px;
    --labelSpacing: 1px;

    --glowA: .45; --glowB: .45; --glowC: .22;

    --spinThick: 3;
    --spinWin: #00ff00;
    --spinLose: #00ff00;
    --pulseWin: #ffff00;
    --pulseLose: #ffff00;

    --sheenOpacity: .35;
    --sheenSpeed: 3.2s;

    --scanOpacity: .14;
    --scanStep: 6px;

    --grainOpacity: .12;
    --grainSize: 120px;

    --vignette: .26;

    --chroma: 2px;

    --emberOpacity: .50;

    --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
  }

  html,body{ margin:0; width:100%; height:100%; background:transparent; overflow:hidden; }
  body{ font-family: var(--font); }
  .stage{ width:100%; height:100%; display:grid; place-items:center; }

  .widget{
    position:relative;
    width: var(--w);
    height: var(--h);
    border-radius: var(--radius);
    background: var(--bg);
    transform: scale(var(--scale));
    box-shadow: inset 0 0 0 2px var(--border), 0 18px 60px rgba(0,0,0,.45);
    overflow:hidden;
    opacity: 1;
    transition: opacity .25s ease, transform .25s ease;
  }
  .widget.hidden{ opacity:0; pointer-events:none; transform: scale(calc(var(--scale)*.985)); }

  /* canvases */
  #embers,#sparks{
    position:absolute; inset:0;
    pointer-events:none;
    z-index:1;
  }
  #embers{ opacity: var(--emberOpacity); mix-blend-mode: screen; }
  #sparks{ opacity: 1; mix-blend-mode: screen; }

  /* Blood canvas */
  #blood{
    position:absolute; inset:0;
    pointer-events:none;
    z-index:2;
    mix-blend-mode: multiply;
  }

  /* FX layers */
  .fx{ position:absolute; inset:0; pointer-events:none; z-index:1; }

  .fx.sheen{
    opacity: var(--sheenOpacity);
    background: linear-gradient(120deg,
      transparent 0%,
      var(--hl_22) 22%,
      transparent 45%,
      rgba(255,255,255,.10) 55%,
      transparent 75%,
      transparent 100%);
    transform: translateX(-75%) skewX(-18deg);
    animation: sheenMove var(--sheenSpeed) linear infinite;
    mix-blend-mode: screen;
    filter: blur(1px);
  }
  @keyframes sheenMove{ 0%{transform:translateX(-75%) skewX(-18deg)} 100%{transform:translateX(75%) skewX(-18deg)} }

  .fx.scan{
    opacity: var(--scanOpacity);
    background: repeating-linear-gradient(to bottom,
      rgba(255,255,255,.05) 0px,
      rgba(255,255,255,.05) 1px,
      rgba(0,0,0,0) 3px,
      rgba(0,0,0,0) var(--scanStep));
    mix-blend-mode: overlay;
    animation: scanShift 6s linear infinite;
  }
  @keyframes scanShift{ 0%{transform:translateY(0)} 100%{transform:translateY(12px)} }

  /* ✅ Grain: avoids blend modes that fail in Streamlabs; uses soft-light fallback */
  .fx.grain{
    opacity: var(--grainOpacity);
    background-image:
      radial-gradient(circle at 18% 22%, rgba(255,255,255,.12) 0 1px, transparent 2px),
      radial-gradient(circle at 77% 36%, rgba(255,255,255,.10) 0 1px, transparent 2px),
      radial-gradient(circle at 42% 78%, rgba(255,255,255,.08) 0 1px, transparent 2px),
      radial-gradient(circle at 58% 55%, rgba(0,0,0,.25) 0 1px, transparent 2px);
    background-size: var(--grainSize) var(--grainSize);
    mix-blend-mode: soft-light;
    animation: grainJitter .55s steps(2,end) infinite;
  }
  @keyframes grainJitter{ 0%{transform:translate(0,0)} 25%{transform:translate(3px,-2px)} 50%{transform:translate(-2px,3px)} 75%{transform:translate(2px,2px)} 100%{transform:translate(-3px,-2px)} }

  .fx.vignette{
    opacity:.95;
    background: radial-gradient(closest-side, transparent 55%, rgba(0,0,0,var(--vignette)) 100%);
  }

  /* ✅ Chroma: simple, reliable, no color-mix */
  .fx.chroma{
    opacity:.85;
    mix-blend-mode: screen;
    filter: blur(.2px);
    animation: chromaFlicker 2.8s steps(2,end) infinite;
  }
  .fx.chroma::before{
    content:"";
    position:absolute; inset:0;
    background: transparent;
    filter:
      drop-shadow(var(--chroma) 0 rgba(255,0,0,.25))
      drop-shadow(calc(var(--chroma) * -1) 0 rgba(0,200,255,.20));
  }
  @keyframes chromaFlicker{
    0%,100%{ transform: translate(0,0); }
    50%{ transform: translate(calc(var(--chroma) * .25), calc(var(--chroma) * -.15)); }
  }

  /* content */
  .row{
    position:relative; z-index:3;
    height:100%;
    display:grid;
    grid-template-columns: var(--colW) 1fr var(--colW);
    align-items:center;
    padding: 0 var(--padX);
    gap: var(--gap);
  }

  .circle{
    position:relative;
    width: var(--circle); height: var(--circle);
    border-radius: 999px;
    background: rgba(0,0,0,.65);
    display:grid; place-items:center;
    box-shadow:
      inset 0 0 0 3px rgba(255,69,0, calc(var(--glowA) * 1)),
      0 0 18px rgba(255,69,0, calc(var(--glowB) * 1)),
      0 0 40px rgba(255,69,0, calc(var(--glowC) * 1));
    user-select:none; overflow:hidden;
  }

  .ring{
    position:absolute; inset:-6px;
    border-radius:999px;
    pointer-events:none;
    border: var(--spinThick) solid transparent;
    opacity: .95;
    animation: spin 1.1s linear infinite;
  }
  @keyframes spin{ to{ transform: rotate(360deg); } }
  .ring.win{ border-top-color: var(--spinWin); border-right-color: rgba(255,255,255,.15); }
  .ring.lose{ border-top-color: var(--spinLose); border-right-color: rgba(255,255,255,.15); }

  .pulseGlow{ position:absolute; inset:0; border-radius:999px; pointer-events:none; opacity:0; }

  .stack{ display:flex; flex-direction:column; align-items:center; justify-content:center; gap: var(--stackGap); transform: translateY(2px); }
  .icon{ width: var(--icon); height: var(--icon); display:grid; place-items:center; }
  .icon img{ width: var(--icon); height: var(--icon); object-fit:contain; filter: drop-shadow(0 10px 18px rgba(0,0,0,.45)) drop-shadow(0 0 10px var(--hl_35)); }
  .iconMask{
    width: var(--icon); height: var(--icon);
    background: var(--highlight);
    filter: drop-shadow(0 10px 18px rgba(0,0,0,.45)) drop-shadow(0 0 10px var(--hl_35));
    -webkit-mask-repeat:no-repeat; -webkit-mask-position:center; -webkit-mask-size:contain;
    mask-repeat:no-repeat; mask-position:center; mask-size:contain;
  }
  .icon svg{ width: var(--icon); height: var(--icon); color: var(--highlight); }

  .label{
    font-weight: 900;
    letter-spacing: var(--labelSpacing);
    text-transform: uppercase;
    color: var(--textSub);
    font-size: var(--labelSize);
    line-height: 1;
    margin: 0;
    text-shadow: 0 6px 16px rgba(0,0,0,.35);
  }

  .center{
    display:grid;
    grid-template-columns: 1fr auto 1fr;
    align-items:center; justify-items:center;
    gap: 20px;
  }
  .num{
    font-size: var(--numSize);
    font-weight: var(--numWeight);
    color: var(--textMain);
    min-width: 110px;
    text-align:center;
    text-shadow: 0 10px 26px rgba(0,0,0,.5);
    user-select:none;
  }
  .dash{
    width: 68px; height: 18px; border-radius:999px;
    background: linear-gradient(90deg, var(--highlight), rgba(255,255,255,.55));
    box-shadow: 0 0 24px var(--hl_35);
    transform: translateY(6px);
  }

  /* punch */
  .pop{ animation: pop .18s ease-out, punchGlow .42s ease-out; }
  @keyframes pop{ 0%{transform:scale(1)} 55%{transform:scale(1.09)} 100%{transform:scale(1)} }
  @keyframes punchGlow{
    0%{ filter: drop-shadow(0 0 0 transparent); }
    55%{ filter: drop-shadow(0 0 18px var(--hl_55)); }
    100%{ filter: drop-shadow(0 0 0 transparent); }
  }
  .widget.shake{ animation: shake .22s ease-out; }
  @keyframes shake{
    0%{ transform: scale(var(--scale)) translate(0,0); }
    20%{ transform: scale(var(--scale)) translate(2px,-1px); }
    40%{ transform: scale(var(--scale)) translate(-2px,1px); }
    60%{ transform: scale(var(--scale)) translate(2px,1px); }
    80%{ transform: scale(var(--scale)) translate(-1px,-2px); }
    100%{ transform: scale(var(--scale)) translate(0,0); }
  }

  /* ✅ Watermark top middle */
  .watermark{
    position:absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 11px;
    letter-spacing: 1.2px;
    color: rgba(255,255,255,.55);
    text-transform: uppercase;
    z-index: 4;
    user-select:none;
    white-space: nowrap;
    text-shadow: 0 8px 22px rgba(0,0,0,.45);
  }
  .status{
    position:absolute;
    right: 12px;
    bottom: 10px;
    font-size: 11px;
    letter-spacing: .9px;
    color: rgba(255,255,255,.45);
    text-transform: uppercase;
    z-index: 4;
    user-select:none;
  }

  .off{ display:none !important; }
</style>
</head>
<body>
<div class="stage">
  <div id="widget" class="widget">
    <canvas id="embers"></canvas>
    <canvas id="sparks"></canvas>
    <canvas id="blood"></canvas>

    <div id="fxSheen" class="fx sheen"></div>
    <div id="fxScan" class="fx scan"></div>
    <div id="fxGrain" class="fx grain"></div>
    <div id="fxVignette" class="fx vignette"></div>
    <div id="fxChroma" class="fx chroma"></div>

    <div class="row">
      <div class="circle">
        <div id="winRing" class="ring win"></div>
        <div id="winGlow" class="pulseGlow"></div>
        <div class="stack">
          <div id="leftIcon" class="icon"></div>
          <div id="leftLabel" class="label">KILLED</div>
        </div>
      </div>

      <div class="center">
        <div id="winNum" class="num">0</div>
        <div class="dash"></div>
        <div id="loseNum" class="num">0</div>
      </div>

      <div class="circle">
        <div id="loseRing" class="ring lose"></div>
        <div id="loseGlow" class="pulseGlow"></div>
        <div class="stack">
          <div id="rightIcon" class="icon"></div>
          <div id="rightLabel" class="label">FAILED</div>
        </div>
      </div>
    </div>

    <div class="watermark" id="wm">GHOSTEPHACE • DBD SCOREBOARD</div>
    <div class="status" id="chatStatus">CHAT: …</div>
  </div>
</div>

<script src="https://unpkg.com/tmi.js@1.8.5/dist/tmi.min.js"></script>
<script>
  const STORAGE_KEY = "dbd_widget_live";

  // Effects OFF by default
  const DEFAULTS = {
    channel: "ghostephace",
    allowEveryone: false,

    scoreWin: 0,
    scoreLose: 0,

    // We keep visibility always; no command-mode settings in UI now
    visibility: "always",

    layout: { w:980, h:170, scale:1, radius:999, padX:18, colW:175, gap:12, circle:140, icon:56, stackGap:4 },
    typography: {
      fontChoice: "system",
      customFont: "",
      font: "ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial",
      numSize:86, numWeight:1000, labelSize:20, labelSpacing:1
    },

    colors: {
      bg:"rgba(13,13,14,.78)",
      border:"rgba(255,255,255,.07)",
      textMain:"#EFEFEF",
      textSub:"#C0C0C0",
      highlight:"#FF4500",
      spinWin:"#00FF00",
      spinLose:"#00FF00",
      pulseWin:"#FFFF00",
      pulseLose:"#FFFF00"
    },

    glow: { a:.45, b:.45, c:.22 },
    spinner: { on:true, thick:3 },

    effects: {
      sheenOn:false, scanOn:false, grainOn:false, vignetteOn:false, chromaOn:false,
      sheenOpacity:.35, sheenSpeedSec:3.2,
      scanOpacity:.14, scanStep:6,
      grainOpacity:.12, grainSize:120,
      vignette:.26,
      chromaPx:2,

      shakeOn:false,
      sparksOn:false, sparksAmount:38,

      // Blood OFF by default
      bloodOn:false,
      bloodColor:"#8b0000",
      bloodOpacity:0.85,
      bloodRate:0.55,
      bloodSpeed:1.05,
      bloodLength:0.75,
      bloodThickness:0.70,
      bloodWobble:0.60
    },

    // Embers OFF by default
    ember: { enabled:false, colors:["#bc2e9f","#FFA500","#bc2e9f"], opacity:.50, speed:.60, targetCount:70 },

    textIcons: {
      leftLabel:"killed", rightLabel:"failed",
      leftIconMode:"svg", rightIconMode:"svg",
      leftIconSvg:"trophy", rightIconSvg:"sad",
      leftIconData:"", rightIconData:"",
      leftTintOn:true, rightTintOn:true,
      leftTintColor:"#FF4500", rightTintColor:"#FF4500"
    },

    watermark: {
      text: "GHOSTEPHACE • DBD SCOREBOARD"
    }
  };

  const $ = (id) => document.getElementById(id);
  const widgetEl = $("widget");

  const winNumEl = $("winNum"), loseNumEl = $("loseNum");
  const leftLabelEl = $("leftLabel"), rightLabelEl = $("rightLabel");
  const leftIconEl = $("leftIcon"), rightIconEl = $("rightIcon");
  const winGlowEl = $("winGlow"), loseGlowEl = $("loseGlow");
  const winRingEl = $("winRing"), loseRingEl = $("loseRing");

  const fxSheen = $("fxSheen"), fxScan = $("fxScan"), fxGrain = $("fxGrain"), fxVignette = $("fxVignette"), fxChroma = $("fxChroma");
  const chatStatusEl = $("chatStatus");
  const wmEl = $("wm");

  function deepMerge(base, patch){
    const out = { ...base };
    for(const k of Object.keys(patch || {})){
      const v = patch[k];
      if(v && typeof v === "object" && !Array.isArray(v)) out[k] = deepMerge(base[k] || {}, v);
      else out[k] = v;
    }
    return out;
  }

  function loadState(){
    try{
      const raw = localStorage.getItem(STORAGE_KEY);
      if(!raw) return structuredClone(DEFAULTS);
      return deepMerge(structuredClone(DEFAULTS), JSON.parse(raw));
    } catch { return structuredClone(DEFAULTS); }
  }

  let state = loadState();
  function saveState(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }

  function clamp(n, min=0, max=99){
    n = Number(n);
    if(!Number.isFinite(n)) n = 0;
    return Math.max(min, Math.min(max, Math.round(n)));
  }

  function hexToRgba(hex, a){
    if(!hex) return `rgba(255,255,255,${a})`;
    const h = hex.replace("#","").trim();
    if(h.length !== 6) return `rgba(255,255,255,${a})`;
    const r = parseInt(h.slice(0,2),16);
    const g = parseInt(h.slice(2,4),16);
    const b = parseInt(h.slice(4,6),16);
    return `rgba(${r},${g},${b},${a})`;
  }

  function resolveFont(){
    const choice = (state.typography.fontChoice || "system").toLowerCase();
    const custom = (state.typography.customFont || "").trim();

    const preset = {
      system: "ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial",
      impact: "Impact, Haettenschweiler, 'Arial Narrow Bold', sans-serif",
      inter: "Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial",
      montserrat: "Montserrat, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial",
      orbitron: "Orbitron, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial",
      bebas: "'Bebas Neue', Impact, ui-sans-serif, system-ui",
      comic: "'Comic Sans MS', 'Comic Sans', ui-sans-serif"
    };

    if(choice === "custom" && custom) return custom;
    return preset[choice] || preset.system;
  }

  function setCSSVars(){
    const r = document.documentElement.style;

    // derived highlight rgba for older CEF compatibility (no color-mix)
    const hl = state.colors.highlight || "#ff4500";
    r.setProperty("--hl_10", hexToRgba(hl, .10));
    r.setProperty("--hl_22", hexToRgba(hl, .22));
    r.setProperty("--hl_35", hexToRgba(hl, .35));
    r.setProperty("--hl_45", hexToRgba(hl, .45));
    r.setProperty("--hl_55", hexToRgba(hl, .55));

    r.setProperty("--scale", state.layout.scale);
    r.setProperty("--w", state.layout.w + "px");
    r.setProperty("--h", state.layout.h + "px");
    r.setProperty("--radius", state.layout.radius + "px");
    r.setProperty("--padX", state.layout.padX + "px");
    r.setProperty("--colW", state.layout.colW + "px");
    r.setProperty("--gap", state.layout.gap + "px");
    r.setProperty("--circle", state.layout.circle + "px");
    r.setProperty("--icon", state.layout.icon + "px");
    r.setProperty("--stackGap", state.layout.stackGap + "px");

    state.typography.font = resolveFont();
    r.setProperty("--font", state.typography.font);
    r.setProperty("--numSize", state.typography.numSize + "px");
    r.setProperty("--numWeight", state.typography.numWeight);
    r.setProperty("--labelSize", state.typography.labelSize + "px");
    r.setProperty("--labelSpacing", state.typography.labelSpacing + "px");

    r.setProperty("--bg", state.colors.bg);
    r.setProperty("--border", state.colors.border);
    r.setProperty("--textMain", state.colors.textMain);
    r.setProperty("--textSub", state.colors.textSub);
    r.setProperty("--highlight", state.colors.highlight);

    r.setProperty("--glowA", state.glow.a);
    r.setProperty("--glowB", state.glow.b);
    r.setProperty("--glowC", state.glow.c);

    r.setProperty("--spinThick", state.spinner.thick);
    r.setProperty("--spinWin", state.colors.spinWin);
    r.setProperty("--spinLose", state.colors.spinLose);
    r.setProperty("--pulseWin", state.colors.pulseWin);
    r.setProperty("--pulseLose", state.colors.pulseLose);

    r.setProperty("--sheenOpacity", state.effects.sheenOpacity);
    r.setProperty("--sheenSpeed", state.effects.sheenSpeedSec + "s");
    r.setProperty("--scanOpacity", state.effects.scanOpacity);
    r.setProperty("--scanStep", state.effects.scanStep + "px");
    r.setProperty("--grainOpacity", state.effects.grainOpacity);
    r.setProperty("--grainSize", state.effects.grainSize + "px");
    r.setProperty("--vignette", state.effects.vignette);

    r.setProperty("--chroma", state.effects.chromaOn ? (state.effects.chromaPx + "px") : "0px");

    r.setProperty("--emberOpacity", state.ember.opacity);
  }

  function iconSVG(name){
    const color = "currentColor";
    if(name === "trophy") return `<svg viewBox="0 0 24 24" fill="none">
      <path d="M8 21h8M12 17v4M7 4h10v4a5 5 0 0 1-10 0V4Z" stroke="${color}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      <path d="M7 6H4v2a4 4 0 0 0 4 4" stroke="${color}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      <path d="M17 6h3v2a4 4 0 0 1-4 4" stroke="${color}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>`;
    if(name === "sad") return `<svg viewBox="0 0 24 24" fill="none">
      <circle cx="12" cy="12" r="9" stroke="${color}" stroke-width="2"/>
      <path d="M9 10h.01M15 10h.01" stroke="${color}" stroke-width="3" stroke-linecap="round"/>
      <path d="M9 17c1.5-1.5 4.5-1.5 6 0" stroke="${color}" stroke-width="2" stroke-linecap="round"/>
    </svg>`;
    if(name === "skull") return `<svg viewBox="0 0 24 24" fill="none">
      <path d="M12 3c-4.4 0-8 3.3-8 7.4 0 2.6 1.4 4.9 3.5 6.2V20c0 .6.4 1 1 1h1v-2h1v2h3v-2h1v2h1c.6 0 1-.4 1-1v-3.4c2.1-1.3 3.5-3.6 3.5-6.2C20 6.3 16.4 3 12 3Z"
            stroke="${color}" stroke-width="2" stroke-linejoin="round"/>
      <circle cx="9" cy="11" r="1.5" fill="${color}"/><circle cx="15" cy="11" r="1.5" fill="${color}"/>
    </svg>`;
    if(name === "exit") return `<svg viewBox="0 0 24 24" fill="none">
      <path d="M10 17l5-5-5-5" stroke="${color}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      <path d="M15 12H3" stroke="${color}" stroke-width="2" stroke-linecap="round"/>
      <path d="M21 4v16" stroke="${color}" stroke-width="2" stroke-linecap="round"/>
    </svg>`;
    return `<svg viewBox="0 0 24 24" fill="none"><circle cx="12" cy="12" r="9" stroke="${color}" stroke-width="2"/></svg>`;
  }

  function setIcon(el, mode, svgName, dataUrl, tintOn, tintColor){
    el.innerHTML = "";
    if(mode === "upload" && dataUrl){
      if(tintOn){
        const mask = document.createElement("div");
        mask.className = "iconMask";
        mask.style.background = tintColor || state.colors.highlight;
        mask.style.webkitMaskImage = `url("${dataUrl}")`;
        mask.style.maskImage = `url("${dataUrl}")`;
        el.appendChild(mask);
      } else {
        const img = document.createElement("img");
        img.alt = ""; img.src = dataUrl;
        el.appendChild(img);
      }
      return;
    }
    el.innerHTML = iconSVG(svgName || "trophy");
    const svg = el.querySelector("svg");
    if(svg) svg.style.color = state.colors.highlight;
  }

  function render(){
    // watermark
    wmEl.textContent = (state.watermark?.text || DEFAULTS.watermark.text).toUpperCase();

    leftLabelEl.textContent  = (state.textIcons.leftLabel  || "killed").toUpperCase();
    rightLabelEl.textContent = (state.textIcons.rightLabel || "failed").toUpperCase();
    winNumEl.textContent = state.scoreWin;
    loseNumEl.textContent = state.scoreLose;

    setIcon(leftIconEl, state.textIcons.leftIconMode, state.textIcons.leftIconSvg, state.textIcons.leftIconData,
      state.textIcons.leftTintOn, state.textIcons.leftTintColor);
    setIcon(rightIconEl, state.textIcons.rightIconMode, state.textIcons.rightIconSvg, state.textIcons.rightIconData,
      state.textIcons.rightTintOn, state.textIcons.rightTintColor);

    fxSheen.classList.toggle("off", !state.effects.sheenOn);
    fxScan.classList.toggle("off", !state.effects.scanOn);
    fxGrain.classList.toggle("off", !state.effects.grainOn);
    fxVignette.classList.toggle("off", !state.effects.vignetteOn);
    fxChroma.classList.toggle("off", !state.effects.chromaOn);

    winRingEl.style.display = state.spinner.on ? "block" : "none";
    loseRingEl.style.display = state.spinner.on ? "block" : "none";
  }

  // punch
  function pop(el){ el.classList.remove("pop"); void el.offsetWidth; el.classList.add("pop"); }
  function doShake(){
    if(!state.effects.shakeOn) return;
    widgetEl.classList.remove("shake"); void widgetEl.offsetWidth; widgetEl.classList.add("shake");
  }
  function flashGlow(which){
    const el = which === "win" ? winGlowEl : loseGlowEl;
    const col = which === "win" ? state.colors.pulseWin : state.colors.pulseLose;
    el.animate([
      { opacity: 0, boxShadow:"0 0 0 0 transparent" },
      { opacity: 1, boxShadow:`0 0 42px 12px ${hexToRgba(col,.60)}` },
      { opacity: 0, boxShadow:"0 0 0 0 transparent" }
    ], { duration: 480, easing:"ease-out" });
  }

  // canvases
  const embersCanvas = $("embers");
  const ectx = embersCanvas.getContext("2d", { alpha:true });
  const sparksCanvas = $("sparks");
  const sctx = sparksCanvas.getContext("2d", { alpha:true });
  const bloodCanvas = $("blood");
  const bctx = bloodCanvas.getContext("2d", { alpha:true });

  let embers = [];
  let sparks = [];
  let drips = [];
  let bloodSpawnAcc = 0;

  let lastT = performance.now();

  function resizeCanvases(){
    const rect = widgetEl.getBoundingClientRect();
    const w = Math.max(1, Math.floor(rect.width));
    const h = Math.max(1, Math.floor(rect.height));
    embersCanvas.width = w; embersCanvas.height = h;
    sparksCanvas.width = w; sparksCanvas.height = h;
    bloodCanvas.width = w;  bloodCanvas.height = h;
  }
  window.addEventListener("resize", resizeCanvases);

  function spawnEmbers(count){
    const w = embersCanvas.width, h = embersCanvas.height;
    const colors = state.ember.colors || ["#FFA500"];
    for(let i=0;i<count;i++){
      embers.push({
        x: Math.random()*w,
        y: h + Math.random()*80,
        r: 1 + Math.random()*2.8,
        vx: (-0.25 + Math.random()*0.5),
        vy: -(0.35 + Math.random()*1.1),
        a: 0.25 + Math.random()*0.8,
        col: colors[Math.floor(Math.random()*colors.length)]
      });
    }
  }

  // ✅ Sparks: stronger + glow + additive blending
  function burstSparks(side){
    if(!state.effects.sparksOn) return;
    const w = sparksCanvas.width, h = sparksCanvas.height;
    const x = side === "win" ? w * 0.18 : w * 0.82;
    const y = h * 0.50;
    const baseCol = side === "win" ? state.colors.spinWin : state.colors.spinLose;
    const amt = clamp(state.effects.sparksAmount, 0, 200);

    for(let i=0;i<amt;i++){
      const ang = Math.random() * Math.PI * 2;
      const spd = 1.4 + Math.random() * 4.0;
      sparks.push({
        x, y,
        vx: Math.cos(ang) * spd,
        vy: Math.sin(ang) * spd - (1.4 + Math.random()*1.2),
        life: 1,
        r: 1.2 + Math.random()*3.8,
        col: baseCol
      });
    }
  }

  // Blood
  function spawnDrip(){
    const w = bloodCanvas.width;
    const h = bloodCanvas.height;

    const thickScale = Number(state.effects.bloodThickness ?? 0.7);
    const lenScale   = Number(state.effects.bloodLength ?? 0.75);
    const wob        = Number(state.effects.bloodWobble ?? 0.6);

    const thick = 2 + thickScale * 10;
    const len   = (0.35 + lenScale * 1.25) * h;

    const x = Math.random() * w;

    drips.push({
      x,
      y: -Math.random() * 25,
      vx: (-0.25 + Math.random() * 0.5) * wob,
      vy: (0.85 + Math.random() * 1.35),
      w: thick * (0.6 + Math.random() * 1.0),
      len: len * (0.25 + Math.random() * 0.70),
      phase: Math.random() * Math.PI * 2,
      life: 1
    });
  }

  function drawDrip(d){
    const col = state.effects.bloodColor || "#8b0000";
    const op  = Math.max(0, Math.min(1, Number(state.effects.bloodOpacity ?? 0.85)));

    bctx.save();
    bctx.globalAlpha = op * d.life;

    bctx.beginPath();
    bctx.lineCap = "round";
    bctx.lineWidth = d.w;
    bctx.strokeStyle = col;
    bctx.moveTo(d.x, d.y);
    bctx.lineTo(d.x, d.y + d.len);
    bctx.stroke();

    bctx.beginPath();
    bctx.fillStyle = col;
    bctx.arc(d.x, d.y + d.len, d.w * 0.65, 0, Math.PI * 2);
    bctx.fill();

    bctx.globalAlpha = op * d.life * 0.16;
    bctx.strokeStyle = "rgba(255,255,255,.35)";
    bctx.lineWidth = Math.max(1, d.w * 0.22);
    bctx.beginPath();
    bctx.moveTo(d.x - d.w * 0.22, d.y + d.w);
    bctx.lineTo(d.x - d.w * 0.22, d.y + d.len * 0.55);
    bctx.stroke();

    bctx.restore();
  }

  function step(t){
    const dt = Math.min(40, t - lastT);
    lastT = t;

    // embers
    if(state.ember.enabled){
      const speed = Math.max(0.05, state.ember.speed || 0.6);
      const w = embersCanvas.width, h = embersCanvas.height;
      ectx.clearRect(0,0,w,h);

      const target = Math.max(0, state.ember.targetCount || 70);
      if(embers.length < target) spawnEmbers(Math.min(12, target - embers.length));

      for(const p of embers){
        p.x += p.vx * dt * speed;
        p.y += p.vy * dt * speed;
        p.a -= 0.00075 * dt;

        ectx.beginPath();
        ectx.fillStyle = hexToRgba(p.col, Math.max(0, Math.min(1, p.a)));
        ectx.arc(p.x, p.y, p.r, 0, Math.PI*2);
        ectx.fill();
      }
      embers = embers.filter(p => p.a > 0 && p.y > -60 && p.x > -60 && p.x < w+60);
    } else {
      ectx.clearRect(0,0,embersCanvas.width,embersCanvas.height);
      embers.length = 0;
    }

    // sparks
    sctx.clearRect(0,0,sparksCanvas.width,sparksCanvas.height);
    sctx.save();
    sctx.globalCompositeOperation = "lighter";
    for(const p of sparks){
      p.x += p.vx; p.y += p.vy;
      p.vy += 0.08; p.vx *= 0.985;
      p.life -= 0.020;

      const a = Math.max(0, p.life);
      sctx.beginPath();
      sctx.fillStyle = hexToRgba(p.col, a);
      sctx.shadowColor = p.col;
      sctx.shadowBlur = 14;
      sctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      sctx.fill();
    }
    sctx.restore();
    sparks = sparks.filter(p => p.life > 0);

    // blood
    bctx.clearRect(0,0,bloodCanvas.width,bloodCanvas.height);
    if(state.effects.bloodOn){
      const rate = Math.max(0, Number(state.effects.bloodRate ?? 0.55));
      const speedMul = Math.max(0.1, Number(state.effects.bloodSpeed ?? 1.05));
      const wob = Number(state.effects.bloodWobble ?? 0.6);

      bloodSpawnAcc += (dt / 1000) * rate;
      while(bloodSpawnAcc >= 1){
        spawnDrip();
        bloodSpawnAcc -= 1;
      }

      const h = bloodCanvas.height;

      for(const d of drips){
        d.phase += 0.02 * dt;
        d.x += d.vx * dt * 0.02;
        d.x += Math.sin(d.phase) * wob * 0.06 * dt;
        d.y += d.vy * dt * 0.06 * speedMul;

        if(d.y > h * 0.55) d.life -= 0.0025 * dt;
        drawDrip(d);
      }

      drips = drips.filter(d => d.life > 0 && d.y < h + d.len + 90);
    } else {
      drips.length = 0;
      bloodSpawnAcc = 0;
    }

    requestAnimationFrame(step);
  }

  function applyAll(){
    setCSSVars();
    render();
    resizeCanvases();
  }

  // sync settings->overlay reliably
  window.addEventListener("storage", (e) => {
    if(e.key !== STORAGE_KEY) return;
    state = loadState();
    applyAll();
    ensureTwitch(true);
  });

  let lastRaw = localStorage.getItem(STORAGE_KEY);
  setInterval(() => {
    const raw = localStorage.getItem(STORAGE_KEY);
    if(raw === lastRaw) return;
    lastRaw = raw;
    state = loadState();
    applyAll();
    ensureTwitch(true);
  }, 200);

  applyAll();
  requestAnimationFrame(step);

  // ✅ Twitch chat commands: ONLY win/lose/reset
  let client = null;
  let connectedChannel = null;
  let lastConnectAttempt = 0;

  function setChatStatus(text){
    chatStatusEl.textContent = text;
  }

  function isAllowed(userstate){
    if(state.allowEveryone) return true;
    const b = userstate.badges || {};
    return !!b.broadcaster || !!b.moderator;
  }

  function bumpWin(){
    state.scoreWin = clamp(state.scoreWin + 1, 0, 99);
    saveState(); render();
    pop(winNumEl); flashGlow("win"); doShake(); burstSparks("win");
  }
  function bumpLose(){
    state.scoreLose = clamp(state.scoreLose + 1, 0, 99);
    saveState(); render();
    pop(loseNumEl); flashGlow("lose"); doShake(); burstSparks("lose");
  }
  function resetScores(){
    state.scoreWin = 0; state.scoreLose = 0;
    saveState(); render();
    pop(winNumEl); pop(loseNumEl); doShake();
  }

  function cleanupClient(){
    try{
      if(client){
        client.removeAllListeners();
        client.disconnect();
      }
    } catch {}
    client = null;
    connectedChannel = null;
  }

  function ensureTwitch(force=false){
    const desired = (state.channel || "").replace(/^#/, "").trim().toLowerCase();
    if(!desired){
      cleanupClient();
      setChatStatus("CHAT: NO CHANNEL");
      return;
    }

    if(!force && client && connectedChannel === desired) return;

    // prevent spam connect loops
    const now = Date.now();
    if(!force && (now - lastConnectAttempt) < 2500) return;
    lastConnectAttempt = now;

    cleanupClient();

    try{
      client = new tmi.Client({
        connection: { secure: true, reconnect: true },
        channels: [ desired ]
      });

      client.on("connecting", () => setChatStatus(`CHAT: CONNECTING #${desired}`));
      client.on("connected", () => setChatStatus(`CHAT: CONNECTED #${desired}`));
      client.on("disconnected", () => setChatStatus(`CHAT: DISCONNECTED`));
      client.on("reconnect", () => setChatStatus(`CHAT: RECONNECTING…`));

      client.on("notice", (_chan, msgid, message) => {
        // helpful to see if Twitch rejects anything
        setChatStatus(`CHAT: NOTICE ${msgid}`);
      });

      client.on("message", (_chan, userstate, message, self) => {
        if(self) return;
        const msg = (message||"").trim().toLowerCase();
        if(!msg.startsWith("!")) return;

        if(!isAllowed(userstate)) return;

        if(msg === "!dbdwin") bumpWin();
        else if(msg === "!dbdlose") bumpLose();
        else if(msg === "!dbdreset") resetScores();
      });

      client.connect()
        .then(() => {
          connectedChannel = desired;
          setChatStatus(`CHAT: CONNECTED #${desired}`);
        })
        .catch(() => {
          setChatStatus(`CHAT: FAILED (retrying)`);
        });
    } catch {
      setChatStatus(`CHAT: ERROR`);
    }
  }

  // periodic health check / reconnect (Streamlabs can be flaky)
  setInterval(() => {
    const desired = (state.channel || "").replace(/^#/, "").trim().toLowerCase();
    if(!desired) return;
    if(!client || connectedChannel !== desired){
      ensureTwitch(true);
      return;
    }
    // if tmi drops silently, reconnect
    if(typeof client.readyState === "string" && client.readyState !== "OPEN"){
      ensureTwitch(true);
    }
  }, 6000);

  ensureTwitch(true);
</script>
</body>
</html>
